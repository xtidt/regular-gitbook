# 1. 匹配一个或多个连续字符

用+符号， a+，意思是匹配**1个或多个**字符a；\[0-9\]+，意思是匹配一个或多个数字

![](http://img.blog.csdn.net/20130517144124974)在vim中 + 语法有点不同，要用 '+'，如左示例。

note：\[\w.\] == \[\w.\]，像.  + 这样的元字符，在字符集中可以不转义，但是转义一下也没问题。

![](http://img.blog.csdn.net/20130517144355610)![](http://img.blog.csdn.net/20130517144428391)

\* 用法跟+相同，但是匹配**0个或多个**连续字符

![](http://img.blog.csdn.net/20130517144550889)  匹配0或多个数字，然后跟着abc三个字母

? 匹配**0个或1个**字符（或字符集合）

![](http://img.blog.csdn.net/20130517144727172) ？在vim中的语法也有点不同，要写成 '\?'，如左示例

另外，可以用{}来设置重复次数，例如

a{9}     匹配连续9个a

\[0-9\]{9} 匹配连续9个数字字符

{2}      重复2次

{2,4}    重复2-4次

{2,}     重复至少2次，无上限

![](http://img.blog.csdn.net/20130521143307663)

![](http://img.blog.csdn.net/20130521143524655)

![](http://img.blog.csdn.net/20130521143609513)

注意{}的用法在vim中也有点不同，左{前要加一个‘\’.

元字符的贪婪型和懒惰型版本

\*           \*?

* +?

{n,}        {n,}?

![](http://img.blog.csdn.net/20130521144301187)![](http://img.blog.csdn.net/20130521145151701)![](http://img.blog.csdn.net/20130521145633080)

上面是一个例子，左边是贪婪模式，右边本来的正则应该是&lt;\[Bb\]&gt;.\*?&lt;\/\[Bb\]&gt;，但是好像vim不支持，就找了上面途中所示的方法，效果是一样的，{-}的意思是最短匹配，注意{}在vim中的用法，要加一个\，再看下第3个例子，帮助理解。

# 2. 位置匹配

\b   匹配一个单词的开头或末尾

\B   不匹配一个单词边界   （这个vim也不支持，不演示了，不过notepad++支持，我试过）

\

&lt;

匹配一个单词的开头   不是所有的编辑器都支持

\

&gt;

匹配一个单词的结束

![](http://img.blog.csdn.net/20130521151115039)

![](http://img.blog.csdn.net/20130521153343449)

![](http://img.blog.csdn.net/20130521153438162)

要注意下3个匹配结果的不同，另外，\b不被vim支持，所以只能用后面两种形式。

字母数字下划线是作为单词边界的字符，因此那个+符号，其实跟空格没啥区别。

^    匹配一个字符串的开头

$    匹配一个字符串的结束

![](http://img.blog.csdn.net/20130521150433599)

![](http://img.blog.csdn.net/20130521150546831)

很多正则表达式的实现都支持使用一些特殊的元字符去改变另外一些元字符的行为，用来启动分行匹配模式的\(?m\)记号就是其中一个例子。分行匹配模式使得正则表达式引擎把行分隔符当作一个字符串分隔符来对待。

在分行匹配模式下，^ 不仅匹配正常的字符串开头，还将匹配行分隔符（换行符）后的开始位置（这个位置不可见）；类似地，$ 不仅匹配正常的字符串结尾，还将匹配行分隔符（换行符）后面的结束位置。

在使用时，\(?m\)必须出现在整个模式的最前面，例如下面的例子：

![](http://img.blog.csdn.net/20130521160709425)

在匹配模式前面加上\(?m\)后，vim又不支持了，我用notepad++重新尝试了一下，\(?m\)加与不加效果好像没啥区别，都能够把3行注释找出来。

# 3. 使用子表达式

attention

：

把必须匹配的情况考虑周全并写出一个匹配结果符合预期的正则表达式很容易，但把不需要匹配的情况也考虑周全并确保它们都将被排除在匹配结果之外往往要困难得多

子表达式，用\(\)来定义，在vim中要用

常见用途： 对重复次数元字符的作用对象做出精确的设定和控制； 对\|操作符的OR条件做出准确的定义； 如有必要，子表达式还允许嵌套使用。

![](http://img.blog.csdn.net/20130521161236031)

![](http://img.blog.csdn.net/20130521161354946)

上面的两条正则的匹配结果是一样的，但是右边的实例使用了子表达式。

![](http://img.blog.csdn.net/20130521161818379)

![](http://img.blog.csdn.net/20130521161856581)

'\|'是正则里的'或'运算符

上面两个例子，右边的将19\|20作为一个子表达式，左边的正则'\|'将其两边的部分作为整体来看待，看成了19和20\d{2}，因此左图中之匹配到了19而不是完整的1988.

精确匹配ip，只有0-255才可以的，有下面几种情况：

1）任何一个1位或2位数字

2）任何一个以1开头的3位数字

3）任何一个以2开头，第2位数字在0-4之间的3位数字

4）任何一个以25开头，第3位数字在0-5之间的3位数字

![](http://img.blog.csdn.net/20130521163103404)

![](http://img.blog.csdn.net/20130521163151103)

